import kotlin.math.exp

class Matrix(val data: List<List<Double>>) {
    val m: Int = data.size
    val n: Int = data.first().size

    operator fun times(other: Matrix): Matrix {
        if (n != other.m) {
            throw IllegalArgumentException("Incompatible matrix dimensions for multiplication.")
        }
        val resultData = List(m) { MutableList(other.n) { 0.0 } }
        for (i in 0 until m) {
            for (j in 0 until other.n) {
                for (k in 0 until n) {
                    resultData[i][j] += this.data[i][k] * other.data[k][j]
                }
            }
        }
        return Matrix(resultData)
    }

    operator fun plus(other: Matrix): Matrix {
        if (m != other.m || n != other.n) {
            throw IllegalArgumentException("Incompatible matrix dimensions for addition.")
        }
        val resultData = List(m) { MutableList(n) { 0.0 } }
        for (i in 0 until m) {
            for (j in 0 until n) {
                resultData[i][j] = this.data[i][j] + other.data[i][j]
            }
        }
        return Matrix(resultData)
    }

    override fun toString() = data.fold("") { acc, row ->
            "$acc${row.joinToString(" ")}\n"
        }

    override fun equals(other: Any?) = if (other !is Matrix) false else data == other.data
    override fun hashCode(): Int { // To be honest hashCode was generated by IDEA
        var result = data.hashCode()
        result = 31 * result + m
        result = 31 * result + n
        return result
    }
}



fun sigmoid(x: Double) = 1.0 / (1 + exp(-x))

fun relu(x: Double) = if (x < 0) 0.0 else x

fun Matrix.sigmoid() = Matrix(data.map { row -> row.map { sigmoid(it) } })

fun Matrix.relu() = Matrix(data.map { row -> row.map { relu(it) } })
